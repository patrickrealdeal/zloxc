// Test: Scoping and Closures with Types
// Tests variable scoping, shadowing, closures, and upvalues with the type system

print "=== Scoping Tests ===";

// === BASIC SCOPING ===
var global : int = 100;
print global;  // Should print: 100

{
    var local : int = 50;
    print local;  // Should print: 50
    print global;  // Should print: 100 (can access global)
}

// local is out of scope here
print global;  // Should print: 100

// === VARIABLE SHADOWING ===
print "=== Shadowing Tests ===";

var x : int = 10;
print x;  // Should print: 10

{
    var x : int = 20;  // Shadows outer x
    print x;  // Should print: 20
    
    {
        var x : int = 30;  // Shadows middle x
        print x;  // Should print: 30
    }
    
    print x;  // Should print: 20 (back to middle scope)
}

print x;  // Should print: 10 (back to outer scope)

// === CLOSURES ===
print "=== Closure Tests ===";

// Simple closure
fun makeCounter() : void {
    var count : int = 0;
    
    fun increment() : int {
        count = count + 1;
        return count;
    }
    
    print increment();  // Should print: 1
    print increment();  // Should print: 2
    print increment();  // Should print: 3
}

makeCounter();

// Closure with parameter
fun makeAdder(n: int) : void {
    fun add(x: int) : int {
        return x + n;  // Captures n from outer scope
    }
    
    print add(5);   // Should print: 5 + n
    print add(10);  // Should print: 10 + n
}

makeAdder(100);  // Should print: 105, 110

// === MULTIPLE CLOSURES ===
print "=== Multiple Closures ===";

fun multipleClosure() : void {
    var a : int = 1;
    var b : int = 2;
    
    fun printA() : void {
        print a;
    }
    
    fun printB() : void {
        print b;
    }
    
    fun modifyBoth() : void {
        a = a + 10;
        b = b + 20;
    }
    
    printA();  // Should print: 1
    printB();  // Should print: 2
    modifyBoth();
    printA();  // Should print: 11
    printB();  // Should print: 22
}

multipleClosure();

// === NESTED FUNCTIONS WITH TYPES ===
print "=== Nested Functions ===";

fun outer(x: int) : void {
    var outerVar : int = x * 2;
    
    fun middle(y: int) : void {
        var middleVar : int = y + outerVar;
        
        fun inner(z: int) : void {
            print z + middleVar + outerVar;  // Uses all three scopes
        }
        
        inner(5);
    }
    
    middle(10);
}

outer(3);  // outerVar=6, middleVar=16, inner gets 5 -> 5+16+6=27

// === CLOSURE WITH DIFFERENT TYPES ===
print "=== Mixed Type Closures ===";

fun mixedClosure() : void {
    var count : int = 0;
    var name : string = "Counter";
    var active : bool = true;
    
    fun display() : void {
        if (active) {
            print name;
            print count;
        }
    }
    
    fun increment() : void {
        if (active) {
            count = count + 1;
        }
    }
    
    display();    // Should print: Counter, 0
    increment();
    display();    // Should print: Counter, 1
    increment();
    display();    // Should print: Counter, 2
}

mixedClosure();

// === LOOP WITH CLOSURES ===
print "=== Loop Closures ===";

// Note: In many languages this is tricky - each iteration should capture its own value
for (var i : int = 0; i < 3; i = i + 1) {
    var captured : int = i;
    
    fun printCaptured() : void {
        print captured;
    }
    
    printCaptured();  // Should print: 0, 1, 2
}

// === RETURNING FUNCTIONS (if supported) ===
// This tests if your language supports returning functions
// If not supported, you can comment this out

print "=== Function Returns ===";

fun makeMultiplier(factor: int) : void {
    // If you support returning functions, this would return a closure
    // For now, just demonstrate the closure works
    
    fun multiply(n: int) : int {
        return n * factor;
    }
    
    print multiply(5);   // Should print: 5 * factor
    print multiply(10);  // Should print: 10 * factor
}

makeMultiplier(3);  // Should print: 15, 30

// === BLOCK SCOPING IN CONDITIONALS ===
print "=== Block Scoping in If/While ===";

var condition : bool = true;
if (condition) {
    var blockVar : int = 123;
    print blockVar;  // Should print: 123
}
// blockVar is not accessible here

var loopCount : int = 0;
while (loopCount < 2) {
    var loopVar : string = "loop";
    print loopVar;  // Should print: "loop" twice
    loopCount = loopCount + 1;
}
// loopVar is not accessible here

print "=== Scoping Tests Complete ===";

